const fs = require("fs");
const seedrandom = require("seedrandom");

/**
 * Die Config wo alle Informationen aufgeschrieben sind.\
 * Ohne sie würde alles den Bach Runter gehen XD.
 * 
 * Ich sollte mal schlafen gehen, wir haben es am 19.06.2025 um 02:02 Uhr Morgens XD.
 * 
 * @type {{"seed": "Main" | string, "radius": number, "count": number, "exponent": number, "mainBlackHoleName": string, "types": {"chance": number, "minDistance": number, "maxDistance": number, "preferred": string|"", "type": string[]}[]}} */
const config = JSON.parse(fs.readFileSync("config.json", "utf-8"));

/**
 * Der seed basierend auf der config.json/seed
 */
const rng = seedrandom(config.seed);

/**
 * Alle Objekte in der Galaxie die bisher Generiert wurden
 * 
 * @type {{type: string, x: number, y: number, name: string, metadata: []}} */
const galaxy = [];

/**
 * ähm... ja, danke ChatGPT. XD
 * 
 * @param r 
 * @param angle 
 * @returns 
 */
function polarToCartesian(r, angle) {
    return {
        x: r * Math.cos(angle),
        y: r * Math.sin(angle)
    };
}

/**
 * Hier wird eine Seedbasierte Distanz generiert.\
 * hab einfach ChatGPT Gefragt lol.
 * 
 * @param min {number}
 * @param max {number}
 * @returns {number}
 */
function getRandomDistance(min, max) {
    if (max === 0) max = config.radius;

    const exponent = config.exponent || 1; // 1 = linear, >1 = mehr im Zentrum

    //// return min + (max - min) * rng();

    return min + (max - min) * Math.pow(rng(), exponent);
}

/**
 * Die Funktion gibt es Extra dafür um Anomalienamen zu Generieren,
 * ich wollte nicht einfach nur Silben für die Namen verwenden also habe ich mich dafür hier entschieden.
 * 
 * @param rng 
 * @returns 
 */
function generateAnomalyName(rng) {
    /**
     * Die Prefixe, quasi die ersten Zeichen die Verwendet werden.
     * @type {string[]}
     */
    const prefix = ["RX", "ZB", "QK", "VR", "IA", "OR", "PA", "TR"];
    const suffix = [];
    for (let i = 0; i < 99; i++) {
        if (i < 10) suffix.push("-0" + i);
        else suffix.push("-" + i)
    }
    for (let i = 0; i < 99; i++) {
        if (i < 10) suffix.push("-0" + i);
        else suffix.push("-MK" + i)
    }

    return prefix[Math.floor(rng() * prefix.length)] + suffix[Math.floor(rng() * suffix.length)];
}

/**
 * Gibt den Sonnenmassenwert basierend auf x zurück.
 * 
 * @param x {number} wert zwischen 0.0000000000000001 - 1.0000000000000000
 * @returns {number} wert zwischen 0.0086 - 100
 */
function generateSolarMass(x) {
    // Der Minimalwert Basierend auf dem Minimalen wert über 0 vom Seed
    if (x <= 0) x == 0.0000000000000001
    // Naja einfach den Wert auf 1 Setzen wenn es über 1 Geht, eigentlich unwahrscheinlich wenn man nur den seed selbst verwendet
    if (x > 1) x == 1.0000000000000000

    return -(1 - Math.pow(x / 1.2, -0.5));
}

/**
 * Gibt Einen Namen basierend auf den Typ des Planeten zurück.
 * 
 * Sehr Interessant ist das er Basierend auf Silben Generiert wird, ich wusste davor nicht einmal, dass das geht.\
 * Danke ChatGPT XD.
 * 
 * @param type typ des Objektes
 * @param rng seed Funktion
 * @returns 
 */
function generateName(type, rng) {
    if (type === "anomaly") { return generateAnomalyName(rng) };

    /**@type {string[]} Silben von ChatGPT für die Namensgenerierung */
    const syllables = [
        // Silben V1
        "ka", "lo", "ra", "ze", "tu", "mi", "xa", "vi", "no",
        "shi", "dra", "qu", "ly", "tor", "zan", "ny", "fel", "vra",
        "zur", "kre", "tho", "bal", "ix", "sy", "jen", "kul", "orn",
        "nef", "ria", "sol", "mek", "tas", "lur", "xen", "cai", "vor",
        "hel", "ume", "zan", "tha", "py", "rek", "gri", "yul", "zan",
        "eph", "ari", "zho", "the", "mur", "dax", "nix", "zor", "lim",

        // Silben V2
        "bri", "clo", "dre", "fen", "gla", "hro", "jor", "kli", "mar",
        "nel", "oph", "pra", "qua", "rin", "sha", "tre", "uln", "vex",
        "wra", "xis", "yra", "zor", "bex", "dru", "fla", "gra", "hul",
        "jum", "kor", "lek", "mip", "nox", "opl", "pru", "qui", "rax",
        "syl", "tri", "uvo", "vyn", "wex", "xil", "yan", "zep", "zor",
        "bax", "cro", "dav", "elx", "fra", "gyn", "hax", "jin", "kre",
        "lom", "myr", "nov", "oph", "plu", "qir", "rum", "syn", "tor",
        "urn", "vok", "wir", "xon", "yar", "zun"
    ];

    let name = "";
    const length = 2 + Math.floor(rng() * 2);
    for (let i = 0; i < length; i++) {
        name += syllables[Math.floor(rng() * syllables.length)];
    }
    return name.charAt(0).toUpperCase() + name.slice(1);
}

const usedNames = new Set();

function generateUniqueName(type, rng) {
    let name;
    let tries = 0;
    do {
        name = generateName(type, rng);
        tries++;
        if (tries > 100) {
            name += `-ZU${Math.floor(rng() * 100)}`;
        }
    } while (usedNames.has(name));
    usedNames.add(name);
    return name;
}

function validateDistance(distance, angle, chosenType) {
    const { x, y } = polarToCartesian(distance, angle)

    const stars = getObjectType("star");

    const typeConfig = config.types[chosenType]

    let dx = 0;
    let dy = 0;
    let tooClose = false

    if (galaxy.length === 0) {
        return { tooClose, x, y, dx, dy }
    }

    if (typeConfig.preferred.startsWith("nearStar")) {
        const parts = typeConfig.preferred.split("-");
        if (parts.length === 3) {
            const nearMin = parseFloat(parts[1]);
            const nearMax = parseFloat(parts[2]);

            const target = stars[Math.floor(rng() * stars.length)];
            const dist = nearMin + rng() * (nearMax - nearMin);
            dx = target.x + Math.cos(angle) * dist;
            dy = target.y + Math.sin(angle) * dist;
        }
    }

    if (typeConfig.preferred?.startsWith("deepSpace")) {
        const parts = typeConfig.preferred.split("-");
        if (parts.length === 2) {
            const min = parseFloat(parts[1]);
            for (const obj of galaxy) {
                if (obj.type === "star") {
                    const dx = obj.x - x;
                    const dy = obj.y - y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < min) {
                        tooClose = true;
                        break;
                    }
                }
            }
        }
    }

    for (const obj of galaxy) {
        if (obj.type === chosenType) {
            const dx = obj.x - x;
            const dy = obj.y - y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < typeConfig.minDistance) {
                tooClose = true;
                break;
            }
        }
    }

    return { tooClose, x, y, dx, dy }
}

function getObjectType(objectType) {
    const all = []
    for (const obj of galaxy) {
        if (obj.type == objectType) {
            all.push(obj)
        }
    }
    return all;
}

function getRandomObjectType(objectType) {
    const all = getObjectType(objectType)

    return all[(rng() * (all.length - 1))];
}

const VALID_SPACE_OBJECTS = ["mainBlackHole", "star", "planet", "astroidfieldt1_astroid", "astroidfieldt2_astroid", "astroidfieldt3_astroid", "rogue_planet", "anomaly", "blackHole"]
const VALID_PLANETARY_RESOURCES = ["iron", "copper", "cobalt", "titanium", "hydrogen", "argon", "uranium", "tungsten"];
const VALID_PLANETARY_SPECIALRESOURCES = ["razetulim", "zanzorlim", "mekballim", "helumelim"];

/**
 * Zulässige Ressourcen (nur Planeten/Einzelgänger/Asteroiden) (resource):\
 * iron, copper, cobalt, titanium, hydrogen, argon, uranium, tungston
 * 
 * Zulässige Spezialressourcen (nur Planeten/Einzelgänger/Asteroiden) (specialresource):\
 * razetulim, zanzorlim, mekballim, helumelim
 * 
 * Zulässige Sterneneigenschaften:\
 * erstmal Nix
 * 
 * Diese Informationen werden Automatisch Via Seed "Erfunden"
 * star:\
 * Spektralklasse via Seed + Tabelle\
 * Masse via Spektralklasse + Tabelle\
 * Subspektralklasse via Seed + Masse\
 * Temperatur via Seed + Subspektralklasse
 * 
 * @param type {string|"mainBlackHole"|"star"|"planet"|"astroidfieldt1_astroid"|"astroidfieldt2_astroid"|"astroidfieldt3_astroid"|"rogue_planet"|"anomaly"|"blackHole"}
 * @param x {number}
 * @param y {number}
 * @param name {string}
 * @param metadata {{resource: {}, specialresource: {}}}
 */
function galaxyPush(type, x, y, name, metadata = { resource: {}, specialresource: {} }) {

    /**@type {{resource: {res:string, amount:number}[], specialresource: {res:string, amount:number}[], informationType: "star"|"planet"|"astroidField", informationBase: {}|null}} */
    const metadata_edit1 = { resource: [], specialresource: [], features: [], informationType: null, informationsBase: null };
    const metadata_edit2 = {};

    if (type != "mainBlackHole") {
        /**
         * Die Grund-Informationen für den Stern
         * 
         * starTemperature: Sternentemparatur in °K\
         * starMass: Sternenmasse in Sonnenmassen\
         * starLum: Sternenleuchtstärke in Sonnenleuchtstärken
         * starSpectral: Spektrum des Sterns:
         *  - h=Hauptsprektrum
         *  - s=Subspektrum
         * 
         * @type {{starTemperature: number, starMass: number, starLum: number, starSpectral: {h:string, s:string}}}
         */
        const informationStar = {
            starTemperature: null,
            starMass: null,
            starLum: null,
            starSpectral: { h: null, s: null }
        }
        /**@type {{}} */
        const planet = {}
        /**@type {{}} */
        const astroidField = {}

        if (type == "star") { metadata_edit1.informationType = "star"; metadata_edit1.informationBase = informationStar }

        //* Ressourcen (resource)
        //// if (metadata.resource.iron != null) { metadata_edit1.resource.push({ res: "iron", amount: metadata.resource.iron }) }
        //// if (metadata.resource.copper != null) { metadata_edit1.resource.push({ res: "copper", amount: metadata.resource.copper }) }
        //// if (metadata.resource.cobalt != null) { metadata_edit1.resource.push({ res: "cobalt", amount: metadata.resource.cobalt }) }
        //// if (metadata.resource.titanium != null) { metadata_edit1.resource.push({ res: "titanium", amount: metadata.resource.titanium }) }
        //// if (metadata.resource.hydrogen != null) { metadata_edit1.resource.push({ res: "hydrogen", amount: metadata.resource.hydrogen }) }
        //// if (metadata.resource.argon != null) { metadata_edit1.resource.push({ res: "argon", amount: metadata.resource.argon }) }
        //// if (metadata.resource.uranium != null) { metadata_edit1.resource.push({ res: "uranium", amount: metadata.resource.uranium }) }
        //// if (metadata.resource.tungsten != null) { metadata_edit1.resource.push({ res: "tungsten", amount: metadata.resource.tungsten }) }
        for (const [res, amount] of Object.entries(metadata.resource || {})) {
            if (VALID_PLANETARY_RESOURCES.includes(res)) {
                metadata_edit1.resource.push({ res, amount });
            }
        }

        //* Spezielle Ressourcen (specialresource)
        //// if (metadata.specialresource.razetulim != null) { metadata_edit1.specialresource.push({ res: "razetulim", amount: metadata.specialresource.razetulim }) }
        //// if (metadata.specialresource.zanzorlim != null) { metadata_edit1.specialresource.push({ res: "zanzorlim", amount: metadata.specialresource.zanzorlim }) }
        //// if (metadata.specialresource.mekballim != null) { metadata_edit1.specialresource.push({ res: "mekballim", amount: metadata.specialresource.mekballim }) }
        //// if (metadata.specialresource.helumelim != null) { metadata_edit1.specialresource.push({ res: "helumelim", amount: metadata.specialresource.helumelim }) }
        for (const [res, amount] of Object.entries(metadata.specialresource || {})) {
            if (VALID_PLANETARY_SPECIALRESOURCES.includes(res)) {
                metadata_edit1.specialresource.push({ res, amount });
            }
        }

        //// Planetare/Stellare/Interstellare Eigenschaften (features)
        //// for (let i = 0; i < metadata.features.length; i++) {
        ////     const e = metadata.features[i];
        ////     for (let j = 0; j < VALID_PLANETARY_FEATURES.length; j++) {
        ////         const f = VALID_PLANETARY_FEATURES[j];
        ////         if (e.toLowerCase() == f.toLowerCase()) metadata_edit1.features.push(f)
        ////     }
        //// }

        if (metadata_edit1.resource.length != 0) { metadata_edit2.resource = metadata_edit1.resource }
        if (metadata_edit1.specialresource.length != 0) { metadata_edit2.specialresource = metadata_edit1.specialresource }
        if (metadata_edit1.features.length != 0) { metadata_edit2.features = metadata_edit1.features }
    } else {
        x = 0;
        y = 0;
        name = config.mainBlackHoleName;
    }

    if (type == "star") {

    }

    //// const distanceToCenter = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    const distanceToCenter = Math.hypot(x, y);

    const d = {
        type,
        x,
        y,
        name,
        distanceToCenter,
        metadata: metadata_edit2
    }
    console.log(JSON.stringify(d));

    // console.log(d.chosenType);

    galaxy.push(d)
}
galaxyPush("mainBlackHole")

while (galaxy.length < config.count) {
    const angle = rng() * Math.PI * 2;
    const typeKeys = Object.keys(config.types);
    const chosenType = typeKeys.find(key => rng() < config.types[key].chance);

    if (!chosenType) continue;

    const typeConfig = config.types[chosenType];
    let distance = getRandomDistance(typeConfig.minDistance || 0, typeConfig.maxDistance || 0);

    const stars = getObjectType("star");

    // === nearStar ===
    if (typeConfig.preferred?.startsWith("nearStar")) {
        const parts = typeConfig.preferred.split("-");
        if (parts.length === 3 && stars.length > 0) {
            const nearMin = parseFloat(parts[1]);
            const nearMax = parseFloat(parts[2]);
            const target = stars[Math.floor(rng() * stars.length)];

            const angleTo = rng() * Math.PI * 2;
            const dist = nearMin + rng() * (nearMax - nearMin);

            const x = target.x + Math.cos(angleTo) * dist;
            const y = target.y + Math.sin(angleTo) * dist;

            const { tooClose } = validateDistance(0, 0, chosenType);
            if (!tooClose) {
                galaxyPush(chosenType, x, y, generateUniqueName(chosenType, rng));
            }
            continue;
        }
    }

    // === Alle anderen ===
    const { tooClose, x, y } = validateDistance(distance, angle, chosenType);
    if (!tooClose) {
        galaxyPush(chosenType, x, y, generateUniqueName(chosenType, rng));
    }
}

fs.writeFileSync("./public/galaxy.json", JSON.stringify(galaxy));
console.log(rng());

console.log("💫 Galaxie generiert mit", galaxy.length, "Objekten.");