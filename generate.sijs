const fs = require("fs");
const seedrandom = require("seedrandom");
const cc = require("./color.js")

/**
 * Die Config wo alle Informationen aufgeschrieben sind.\
 * Ohne sie würde alles den Bach Runter gehen XD.
 * 
 * Sie beinhaltet nur die Basic Informationen, die Ressourcen werden in ./resource_config.json gespeichert
 * 
 * Ich sollte mal schlafen gehen, wir haben es am 19.06.2025 um 02:02 Uhr Morgens XD.
 * 
 * @type {{"seed": "Main" | string, "radius": number, "count": number, "stellarPlanetCount": {"min": number, "max": number}, "stellarAstroidCount": {"min": number, "max": number}, "exponent": number, "mainBlackHoleName": string, "types": {"chance": number, "minDistance": number, "maxDistance": number, "preferred": string|"", "type": string[]}[]}} */
const config = JSON.parse(fs.readFileSync("config.json", "utf-8"));

/**
 * Hier werden alle Ressourceninformationen abgespeichert.
 * Angefangen mit einem Array wo alles Ressourcen abgespeichert werden gefolgt von ihen detaillierten Informationen.
 * 
 * das layout wird immer so sein:
 * "typ:ressource"
 * also zb
 * standard:iron_ore
 * advanced:gold_ore
 * astroid:methane_ice
 * gas:hydrogen
 * 
 * @type {{"resources": string[], standard_resource_information: {name: string, vorkommen: string[]}[], "advanced_resource_information": {name: string, vorkommen: string[]}[], "astroid_resource_information": {name: string, vorkommen: string[]}[], "gas_resource_information": {name: string, vorkommen: string[]}[]}}
 */
const resource_config = JSON.parse(fs.readFileSync("./resource_config.json", "utf-8"));

/**
 * Der seed basierend auf der config.json/seed
 */
const rng = seedrandom(config.seed);

/**@type {6.67430e-11} Die Gravitationskonstante */
const G = 6.67430e-11;
/**@type {149597870700} Die Länge einer Astronomischen Einheit in Meter */
const AE = 149_597_870_700;
/**@type {9460730472580800n} Die Länge eines Lichtjahres in Meter */
const LJ = 9_460_730_472_580_800n;
/**@type {31557600} Die Länge eines Jahres in Sekunden */
const YEAR_IN_SEC = 31_557_600;
/**@type {1.9884e30} Masse der Sonne in KG */
const SUN_MASS_KG = 1.9884e30;
/**@type {5.972e24} Masse der Erde in KG */
const EARTH_MASS_KG = 5.972e24;
/**@type {number} Die Maximale Anzahl an Planeten die in einem Sternensystem vorhanden sein dürfen */
const MAX_PLANETS_PER_SOLSYS = 10;
/**@type {number} Die Maximale Anzahl an Monden die um einen Planeten vorhanden sein dürfen */
const MAX_MOONS_PER_PLANET = 3;
/**Berechnet die Orbitalgeschwindigkeit @param {number} mass @param {number} height @returns {number} */
const calculateOrbitalSpeed = (mass, height) => { return }

/**
 * Alle Objekte in der Galaxie die bisher Generiert wurden
 * 
 * @type {{type: string, x: number, y: number, name: string, metadata: []}[]} */
const galaxy = [];

/**
 * ähm... ja, danke ChatGPT. XD
 * 
 * Ich glaube das generiert die `x` und `y` koordinaten die nicht
 * weiter als der Radius der Galaxie entfernt sein dürfen
 * 
 * @param r 
 * @param angle 
 * @returns 
 */
function polarToCartesian(r, angle) {
    return {
        x: r * Math.cos(angle),
        y: r * Math.sin(angle)
    };
}

/**
 * Hier wird eine Seedbasierte Distanz generiert.\
 * hab einfach ChatGPT Gefragt lol.
 * 
 * @param min {number}
 * @param max {number}
 * @returns {number}
 */
function getRandomDistance(min, max) {
    if (max === 0) max = config.radius;

    const exponent = config.exponent || 1; // 1 = linear, >1 = mehr im Zentrum

    //// return min + (max - min) * rng();

    return min + (max - min) * Math.pow(rng(), exponent);
}

/**
 * Die Funktion gibt es Extra dafür um Anomalienamen zu Generieren,
 * ich wollte nicht einfach nur Silben für die Namen verwenden also habe ich mich dafür hier entschieden.
 * 
 *  Weil es sich für Anomalien besser anhört
 * 
 * @param rng 
 * @returns 
 */
function generateAnomalyName(rng) {
    /**
     * Die Prefixe, quasi die ersten Zeichen die Verwendet werden.
     * @type {string[]}
     */
    const prefix = ["RX", "ZB", "QK", "VR", "IA", "OR", "PA", "TR"];
    /**
     * Das sind die Suffixe die nach den Prefixen kommen,
     * sie bestehen aus nur eine Zahl oder MK + Zahl.
     * @type {string[]}
     */
    const suffix = [];
    for (let i = 0; i < 99; i++) {
        if (i < 10) suffix.push("-0" + i);
        else suffix.push("-" + i)
    }
    for (let i = 0; i < 99; i++) {
        if (i < 10) suffix.push("-0" + i);
        else suffix.push("-MK" + i)
    }

    return prefix[Math.floor(rng() * prefix.length)] + suffix[Math.floor(rng() * suffix.length)];
}

/**
 * Gibt den Sonnenmassenwert basierend auf x zurück.
 * 
 * @param x {number} wert zwischen `0.0000000000000001` - `1.0000000000000000`
 * @returns {number} wert zwischen `0.0086` - `100`
 */
function generateSolarMass(x) {
    // Der Minimalwert Basierend auf dem Minimalen wert über 0 vom Seed
    if (x <= 0) x = 0.0000000000000001;
    // Naja einfach den Wert auf 1 Setzen wenn es über 1 Geht, eigentlich unwahrscheinlich wenn man nur den seed selbst verwendet
    if (x > 1) x = 1.0000000000000000;

    return -(1 - Math.pow(x / 1.2, -0.4));
}

/**
 * Alle Validen Werte für jeden Spektrum.
 *
 * Hier habe ich natürlich einige Simplifikationen durchgeführt, besonders bei der Klasse `M`, `L`, `T` und `Y`.
 * 
 * @type {{class:string, tempmin:number, tempmax: number, massmin: number, massmax: number}[]}
 */
const VALID_SPECTRAL_CLASS_VALUES = [
    { class: "O", tempmin: 30000, tempmax: 60000, massmin: 16, massmax: Infinity },
    { class: "B", tempmin: 10000, tempmax: 30000, massmin: 2.1, massmax: 16 },
    { class: "A", tempmin: 7500, tempmax: 10000, massmin: 1.7, massmax: 2.1 },
    { class: "F", tempmin: 6000, tempmax: 7500, massmin: 1.1, massmax: 1.7 },
    { class: "G", tempmin: 5300, tempmax: 6000, massmin: 0.8, massmax: 1.1 },
    { class: "K", tempmin: 3500, tempmax: 5300, massmin: 0.5, massmax: 0.8 },
    { class: "M", tempmin: 2500, tempmax: 3500, massmin: 0.03, massmax: 0.5 },
    { class: "L", tempmin: 1300, tempmax: 2500, massmin: 0.05, massmax: 0.03 },
    { class: "T", tempmin: 800, tempmax: 1300, massmin: 0.01, massmax: 0.03 },
    { class: "Y", tempmin: 0, tempmax: 800, massmin: 0.0083, massmax: 0.01 },
]

/**
 * Die Luminosität der Sonne in Watt
 * @type {number}
 */
const LUM_SOL = 3.828 * Math.pow(10, 26); // W
/**
 * Der Radius der Sonne in KM
 * @type {number}
 */
const R_SOL = 695700; // KM
/**
 * Die (Oberflächen-)Temperatur der Sonne in °K
 * @type {number}
 */
const T_SOL = 5778; // °K
/**
 * Die Masser der Sonne in KG
 * @type {number}
 */
const M_SOL = 1.989 * Math.pow(10, 30); // KG

/**
 * Hier wird die Spektralklasse des Sterns einfach basierend auf der Masse ausgegeben.\
 * Sehr Simpel Gehalten, ich meine wir brauchen hier keine Wissenschaftliche Simulation.
 * 
 * @param mass Die Masse des STerns
 * @returns {{class:string, subclass:string, temp:number, mass_sol: number, lum_sol: number, r_sol: number}}
 */
function getSolarSpectralClassData(mass) {
    /**@type {{class:string, subclass:string, temp:number, mass_sol: number, lum_sol: number, r_sol: number}} */
    let returnData = {};

    returnData.mass_sol = mass;

    /**@type {{class:string, tempmin:number, tempmax: number, massmin: number, massmax: number}} */
    let currentClass = null

    for (let i = 0; i < VALID_SPECTRAL_CLASS_VALUES.length; i++) {
        const specs = VALID_SPECTRAL_CLASS_VALUES[i]
        if (mass >= specs.massmin && mass <= specs.massmax) { currentClass = specs; returnData.class = specs.class; break; }
    }

    for (let i = 0; i < 10; i++) {
        const min = 0;
        const max = currentClass.tempmax - currentClass.tempmin;
        const relmass = mass - currentClass.massmin;

        const massPartStepSize = max / 10;

        if (relmass >= (min + massPartStepSize * i) && relmass <= (min + massPartStepSize * (i + 1))) returnData.subclass = i;
    }

    returnData.temp = Math.round((rng() * (currentClass.tempmax - currentClass.tempmin)) + currentClass.tempmin);

    returnData.r_sol = Math.pow(returnData.mass_sol, 0.8);

    returnData.lum_sol = Math.pow((returnData.r_sol * R_SOL) / R_SOL, 2) * Math.pow(returnData.temp / T_SOL, 4);

    return returnData;
}

/**
 * Gibt Einen Namen basierend auf den Typ des Planeten zurück.
 * 
 * Sehr Interessant ist das er Basierend auf Silben Generiert wird, ich wusste davor nicht einmal, dass das geht.\
 * Danke ChatGPT XD.
 * 
 * Wer das liest ist Dumm.
 * 
 * @param type typ des Objektes
 * @param rng seed Funktion
 * @returns 
 */
function generateName(type, rng) {
    if (type === "anomaly") { return generateAnomalyName(rng) };

    /**@type {string[]} Silben von ChatGPT für die Namensgenerierung */
    const syllables = [
        // Silben V1
        "ka", "lo", "ra", "ze", "tu", "mi", "xa", "vi", "no",
        "shi", "dra", "qu", "ly", "tor", "zan", "ny", "fel", "vra",
        "zur", "kre", "tho", "bal", "ix", "sy", "jen", "kul", "orn",
        "nef", "ria", "sol", "mek", "tas", "lur", "xen", "cai", "vor",
        "hel", "ume", "zan", "tha", "py", "rek", "gri", "yul", "zan",
        "eph", "ari", "zho", "the", "mur", "dax", "nix", "zor", "lim",

        // Silben V2
        "bri", "clo", "dre", "fen", "gla", "hro", "jor", "kli", "mar",
        "nel", "oph", "pra", "qua", "rin", "sha", "tre", "uln", "vex",
        "wra", "xis", "yra", "zor", "bex", "dru", "fla", "gra", "hul",
        "jum", "kor", "lek", "mip", "nox", "opl", "pru", "qui", "rax",
        "syl", "tri", "uvo", "vyn", "wex", "xil", "yan", "zep", "zor",
        "bax", "cro", "dav", "elx", "fra", "gyn", "hax", "jin", "kre",
        "lom", "myr", "nov", "oph", "plu", "qir", "rum", "syn", "tor",
        "urn", "vok", "wir", "xon", "yar", "zun"
    ];

    let name = "";
    const length = 2 + Math.floor(rng() * 2);
    for (let i = 0; i < length; i++) {
        name += syllables[Math.floor(rng() * syllables.length)];
    }
    return name.charAt(0).toUpperCase() + name.slice(1);
}

const usedNames = new Set();

function generateUniqueName(type, rng) {
    let name;
    let tries = 0;
    do {
        name = generateName(type, rng);
        tries++;
        if (tries > 100) {
            name += `-ZU${Math.floor(rng() * 100)}`;
        }
    } while (usedNames.has(name));
    usedNames.add(name);
    return name;
}

/**
 * Validiert die Distanz zwischen Objekten, sodass Objekte nicht zu nah und auch nicht zu weit voneinander sind,
 * basierend auf der config.
 * 
 * @param distance 
 * @param angle 
 * @param chosenType 
 * @returns 
 */
function validateDistance(distance, angle, chosenType) {
    const { x, y } = polarToCartesian(distance, angle)

    const stars = getObjectType("star");

    const typeConfig = config.types[chosenType]

    let dx = 0;
    let dy = 0;
    let tooClose = false

    if (galaxy.length === 0) {
        return { tooClose, x, y, dx, dy }
    }

    if (typeConfig.preferred.startsWith("nearStar")) {
        const parts = typeConfig.preferred.split("-");
        if (parts.length === 3) {
            const nearMin = parseFloat(parts[1]);
            const nearMax = parseFloat(parts[2]);

            const target = stars[Math.floor(rng() * stars.length)];
            const dist = nearMin + rng() * (nearMax - nearMin);
            dx = target.x + Math.cos(angle) * dist;
            dy = target.y + Math.sin(angle) * dist;
        }
    }

    if (typeConfig.preferred?.startsWith("deepSpace")) {
        const parts = typeConfig.preferred.split("-");
        if (parts.length === 2) {
            const min = parseFloat(parts[1]);
            for (const obj of galaxy) {
                if (obj.type === "star") {
                    const dx = obj.x - x;
                    const dy = obj.y - y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < min) {
                        tooClose = true;
                        break;
                    }
                }
            }
        }
    }

    for (const obj of galaxy) {
        if (obj.type === chosenType) {
            const dx = obj.x - x;
            const dy = obj.y - y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < typeConfig.minDistance) {
                tooClose = true;
                break;
            }
        }
    }

    return { tooClose, x, y, dx, dy }
}

function getObjectType(objectType) {
    const all = []
    for (const obj of galaxy) {
        if (obj.type == objectType) {
            all.push(obj)
        }
    }
    return all;
}

function getRandomObjectType(objectType) {
    const all = getObjectType(objectType)

    return all[(rng() * (all.length - 1))];
}

/**
 * Alle Validen Objekte die zur Generierung Verwendet werden dürfen.
 * @type {string[]}
 */
const VALID_SPACE_OBJECTS = ["mainBlackHole", "star", "planet", "t1_astroid", "t2_astroid", "t3_astroid", "rogue_planet", "anomaly", "blackHole", "gas_giant"]
/**
 * Alle Validen Standard Ressourcen die auf Planeten gefunden werden können.
 * @type {string[]}
 */
const VALID_PLANETARY_RESOURCES = [];
/**
 * Alle Validen Fortschrittliche Ressourcen die auf Planeten gefunden werden können.
 * @type {string[]}
 */
const VALID_PLANETARY_SPECIALRESOURCES = [];
/**
 * Alle Validen Standard Ressourcen die auf Stellaren Asteroidenfeldern gefunden werden können.
 * @type {string[]}
 */
const VALID_STELLAR_ASTROID_RESOURCES = [];
/**
 * Alle Validen Fortschrittliche Ressourcen die auf Stellaren Asteroidenfeldern gefunden werden können.
 * @type {string[]}
 */
const VALID_STELLAR_ASTROID_SPECIALRESOURCES = [];
/**
 * Alle Validen Ressourcen die AUF T-1 Interstellaren Asteroidenfeldern gefunden werden können.
 * @type {string[]}
 */
const VALID_AST_1_RESOURCES = [];
/**
 * Alle Validen Ressourcen die AUF T-2 Interstellaren Asteroidenfeldern gefunden werden können.
 * @type {string[]}
 */
const VALID_AST_2_RESOURCES = [];
/**
 * Alle Validen Ressourcen die AUF T-3 Interstellaren Asteroidenfeldern gefunden werden können.
 * @type {string[]}
 */
const VALID_AST_3_RESOURCES = [];

/**
 * 
 */
function init_resources() {
    // Leere die Arrays zuerst
    VALID_PLANETARY_RESOURCES.length = 0;
    VALID_PLANETARY_SPECIALRESOURCES.length = 0;
    VALID_STELLAR_ASTROID_RESOURCES.length = 0;
    VALID_STELLAR_ASTROID_SPECIALRESOURCES.length = 0;
    VALID_AST_1_RESOURCES.length = 0;
    VALID_AST_2_RESOURCES.length = 0;
    VALID_AST_3_RESOURCES.length = 0;

    // resource_config ist vermutlich ein Array von Objekten
    for (const entry of resource_config) {
        // Beispiel: "type": "normal:solid"
        if (entry.type === "normal:solid") {
            VALID_PLANETARY_RESOURCES.push(entry.name);
        }
        // Hier kannst du weitere Typen auswerten, z.B. für Spezialressourcen oder Asteroiden
        // if (entry.type === "special:planet") { ... }
        // if (entry.type === "astroid:t1") { ... }
        // usw.
    }
}

/**
 * Zulässige Ressourcen (nur Planeten/Einzelgänger/Asteroiden) (resource):\
 * iron, copper, cobalt, titanium, hydrogen, argon, uranium, tungston
 * 
 * Zulässige Spezialressourcen (nur Planeten/Einzelgänger/Asteroiden) (specialresource):\
 * razetulim, zanzorlim, mekballim, helumelim
 * 
 * Zulässige Sterneneigenschaften:\
 * erstmal Nix
 * 
 * Diese Informationen werden Automatisch Via Seed "Erfunden"
 * star:\
 * Spektralklasse via Seed + Tabelle\
 * Masse via Spektralklasse + Tabelle\
 * Subspektralklasse via Seed + Masse\
 * Temperatur via Seed + Subspektralklasse
 * 
 * `gasGiant` | `moon` | `planet` | `stellar_astroid_field` sind zwar Valide objekte sind\
 * aber deaktiviert für die Galaxiegenerierung, weil sie nix in der Galaxie zu suchen haben,\
 * sie werden separat in den Sternensystemen Generiert.\
 * Die Gesammtmenge der Objekte in der Galaxie wird dennoch `config.amount` erreichen.
 * 
 * @param type {string|"mainBlackHole"|"star"|"gasGiant"|"moon"|"planet"|"astroidfieldt1_astroid"|"astroidfieldt2_astroid"|"astroidfieldt3_astroid"|"rogue_planet"|"anomaly"|"blackHole"}
 * @param x {number}
 * @param y {number}
 * @param name {string}
 * @param metadata {{resource: {}, specialresource: {}}}
 */
function galaxyPush(type, x, y, name, metadata = { resource: {}, specialresource: {} }) {

    if (type == "planet") return;
    if (type == "gasGiant") return;
    if (type == "moon") return;
    if (type == "stellar_astroid_field") return;

    /**@type {{resource: {res:string, amount:number}[], specialresource: {res:string, amount:number}[], informationType: "star"|"planet"|"astroidField", informationBase: {}|null}} */
    const metadata_edit1 = { resource: [], specialresource: [], features: [], informationType: null, informationsBase: null };
    const metadata_edit2 = {};

    if (type != "mainBlackHole") {
        /**
         * Die Grund-Informationen für den Stern
         * 
         * starTemperature: Sternentemparatur in °K\
         * starMass: Sternenmasse in Sonnenmassen\
         * starLum: Sternenleuchtstärke in Sonnenleuchtstärken\
         * starSpectral: Spektrum des Sterns:
         *  - h=Hauptsprektrum
         *  - s=Subspektrum
         * 
         * Hauptspektrum: Y, T, L, M, K, G (zb. wie unsere Sonne), F, A, B, O\
         * Subspektrul: Y0-Y9, T0-T9, L0-L9, M0-M9, K0-K9, G0-G9 (unsere Sonne ist G-2), F0-F9, A0-A9, B0-B9, O0-O9
         * 
         * @type {{starTemperature: number, starMass: number, starMassKG: number, starRad: number, starLum: number, starSpectral: {h:"Y"|"T"|"L"|"M"|"K"|"G"|"F"|"A"|"B"|"O"|string, s:"0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"|string}, planetSystem: []}}
         */
        const informationStar = {
            starTemperature: null,
            starMass: null,
            starMassKG: null,
            starLum: null,
            starRad: null,
            starSpectral: { h: null, s: null },
            planetSystem: null
        }

        /**
         * 
         * 
         * @type {{massEM: number, massKG: number}}
         */
        const infoRoguePlanet = {
            massEM: null,
            massKG: null,
            height: null,
            orbitPosDegree: null,
            orbitPosNorm: null,
            moons: null
        };

        /**
         * 
         * 
         * @type {{}}
         */
        const astroidField = {}

        if (type == "star") { metadata_edit1.informationType = "star"; metadata_edit1.informationBase = informationStar }

        //* Ressourcen (resource)
        //// if (metadata.resource.iron != null) { metadata_edit1.resource.push({ res: "iron", amount: metadata.resource.iron }) }
        //// if (metadata.resource.copper != null) { metadata_edit1.resource.push({ res: "copper", amount: metadata.resource.copper }) }
        //// if (metadata.resource.cobalt != null) { metadata_edit1.resource.push({ res: "cobalt", amount: metadata.resource.cobalt }) }
        //// if (metadata.resource.titanium != null) { metadata_edit1.resource.push({ res: "titanium", amount: metadata.resource.titanium }) }
        //// if (metadata.resource.hydrogen != null) { metadata_edit1.resource.push({ res: "hydrogen", amount: metadata.resource.hydrogen }) }
        //// if (metadata.resource.argon != null) { metadata_edit1.resource.push({ res: "argon", amount: metadata.resource.argon }) }
        //// if (metadata.resource.uranium != null) { metadata_edit1.resource.push({ res: "uranium", amount: metadata.resource.uranium }) }
        //// if (metadata.resource.tungsten != null) { metadata_edit1.resource.push({ res: "tungsten", amount: metadata.resource.tungsten }) }
        for (const [res, amount] of Object.entries(metadata.resource || {})) {
            if (VALID_PLANETARY_RESOURCES.includes(res)) {
                metadata_edit1.resource.push({ res, amount });
            }
        }

        //* Spezielle Ressourcen (specialresource)
        //// if (metadata.specialresource.razetulim != null) { metadata_edit1.specialresource.push({ res: "razetulim", amount: metadata.specialresource.razetulim }) }
        //// if (metadata.specialresource.zanzorlim != null) { metadata_edit1.specialresource.push({ res: "zanzorlim", amount: metadata.specialresource.zanzorlim }) }
        //// if (metadata.specialresource.mekballim != null) { metadata_edit1.specialresource.push({ res: "mekballim", amount: metadata.specialresource.mekballim }) }
        //// if (metadata.specialresource.helumelim != null) { metadata_edit1.specialresource.push({ res: "helumelim", amount: metadata.specialresource.helumelim }) }
        for (const [res, amount] of Object.entries(metadata.specialresource || {})) {
            if (VALID_PLANETARY_SPECIALRESOURCES.includes(res)) {
                metadata_edit1.specialresource.push({ res, amount });
            }
        }

        //// Planetare/Stellare/Interstellare Eigenschaften (features)
        //// for (let i = 0; i < metadata.features.length; i++) {
        ////     const e = metadata.features[i];
        ////     for (let j = 0; j < VALID_PLANETARY_FEATURES.length; j++) {
        ////         const f = VALID_PLANETARY_FEATURES[j];
        ////         if (e.toLowerCase() == f.toLowerCase()) metadata_edit1.features.push(f)
        ////     }
        //// }

        if (type == "star") {
            const sunMass = generateSolarMass(rng());

            let info = informationStar;

            let minPlanets = Math.round(rng() * MAX_PLANETS_PER_SOLSYS);
            let maxPlanets = Math.round(rng() * (MAX_PLANETS_PER_SOLSYS - minPlanets)) + minPlanets;

            let specs = getSolarSpectralClassData(sunMass);

            info.starLum = specs.lum_sol;
            info.starMass = specs.mass_sol;
            info.starMassKG = specs.mass_sol * SUN_MASS_KG;
            info.starRad = specs.r_sol
            info.starSpectral = { h: specs.class, s: specs.subclass };
            info.starTemperature = specs.temp;
            info.planetSystem = generatePlanetSystemData(name, info.starMassKG, minPlanets, maxPlanets)

            metadata_edit1.informationType = "star";
            metadata_edit1.informationBase = info;
        }

        if (type == "rogue_planet") {
            // Beispielwerte, du kannst sie nach Bedarf anpassen/generieren
            const mass = +(0.1 + rng() * 10).toFixed(3);
            const rotation = Math.round(rng() * 360);
            const moons = generateMoonSystemData(name, mass * EARTH_MASS_KG, Math.round(rng() * MAX_MOONS_PER_PLANET));

            let info = infoRoguePlanet

            info.massEM = mass
            info.massKG = mass * EARTH_MASS_KG
            info.orbitPosDegree = rotation
            info.orbitPosNorm = (rotation / 360).toFixed(3)
            info.moons = moons

            metadata_edit1.informationType = "rogue_planet";
            metadata_edit1.informationBase = info;
        }

    } else {
        x = 0;
        y = 0;
        name = config.mainBlackHoleName;
    }

    if (metadata_edit1.resource.length != 0) { metadata_edit2.resource = metadata_edit1.resource }
    if (metadata_edit1.specialresource.length != 0) { metadata_edit2.specialresource = metadata_edit1.specialresource }
    if (metadata_edit1.informationType != null && metadata_edit1.informationBase != null) { metadata.informationType = metadata_edit1.informationType; metadata_edit2.informationBase = metadata_edit1.informationBase }

    //// const distanceToCenter = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    const distanceToCenter = Math.hypot(x, y);

    const d = {
        type,
        x,
        y,
        name,
        distanceToCenter,
        metadata: metadata_edit2
    }
    console.log(JSON.stringify(d));

    // console.log(d.chosenType);

    galaxy.push(d)
}
galaxyPush("mainBlackHole")

/**
 * Die funktion Generiert ein Array mit Validen Ressourcen Werten bis zu einem Maximalen Ressourcenpunkwert
 * 
 * @param {string} type
 * @param {number} max Der Maximalwert von Ressourcenpunkten, meist so im 1000er Bereich
 * @return {{}}
 */
function resourcerichness(type, max) {
    let current = 0;
    let ressources = [];

    while (current < max) {

    }

    // return Math.round(rng() * 1000);
}

/**
 * Generiert ein Planetensystem (nur Daten, nicht in der Galaxie!).
 * Jeder Planet hat: höhe (Abstand), masse, rotation (in Grad), und ggf. Monde.
 * @param {string} parentStarName
 * @param {number} parentStarMass In KG
 * @param {number} minPlanets
 * @param {number} maxPlanets
 * @returns {Array} Array mit Planeten-Objekten
 */
function generatePlanetSystemData(parentStarName, parentStarMass, minPlanets = 1, maxPlanets = 10) {
    const planets = [];
    const planetCount = minPlanets + Math.floor(rng() * (maxPlanets - minPlanets + 1));
    let lastDistance = 0.1 + rng() * 2; // Startabstand in AE

    for (let i = 0; i < planetCount; i++) {
        lastDistance += 2 + rng() * 5;
        const rotation = Math.round(rng() * 360); // Rotationswinkel in Grad
        const mass = +(0.1 + rng() * 10).toFixed(3); // Masse, z.B. 0.1 - 10 (Erdmassen)
        const name = generateUniqueName("planet", rng);

        const maxMoons = Math.round(rng() * MAX_MOONS_PER_PLANET);
        let moons = [];
        if (maxMoons > 0) {
            moons = generateMoonSystemData(name, mass * EARTH_MASS_KG, maxMoons);
        }

        const OrbitalSpeed = Math.sqrt((G * parentStarMass) / (lastDistance * AE))
        const OrbitalTimeInSec = 2 * Math.PI * Math.sqrt(Math.pow(lastDistance * AE, 3) / (G * parentStarMass));

        planets.push({
            name,
            height: lastDistance,
            massEM: mass,
            massKG: mass * EARTH_MASS_KG,
            OrbitalSpeed,
            OrbitalTimeInSec,
            OrbitalTimeInYears: Math.round((OrbitalTimeInSec / YEAR_IN_SEC) * 1000) / 1000,
            orbitPosDegree: rotation,   // in Grad
            orbitPosNorm: Math.round((rotation / 360) * 1000) / 1000,  // Normalisiert
            moons
        });

        
    }
    return planets;
}

/**
 * Generiert ein Mondsystem für einen Planeten (nur Daten).
 * Jeder Mond hat: höhe (Abstand), masse, rotation (in Grad).
 * @param {string} parentPlanetName
 * @param {number} parentPlanetMass in KG
 * @param {number} maxMoons
 * @returns {Array} Array mit Mond-Objekten
 */
function generateMoonSystemData(parentPlanetName, parentPlanetMass, maxMoons = 5) {
    const moons = [];
    const moonCount = Math.floor(rng() * (maxMoons + 1));
    let lastDistance = 50000 + rng() * 100000; // Startabstand in KM

    for (let i = 0; i < moonCount; i++) {
        const rotation = Math.round(rng() * 360);
        const mass = +(0.01 + rng() * 0.5).toFixed(3); // Masse, z.B. 0.01 - 0.5 (Erdmassen)
        const name = generateUniqueName("moon", rng);

        const OrbitalSpeed = Math.sqrt((G * parentPlanetMass) / (lastDistance * 1000))
        const OrbitalTimeInSec = 2 * Math.PI * Math.sqrt(Math.pow((lastDistance * 1000), 3) / (G * parentPlanetMass));

        moons.push({
            name,
            parent: parentPlanetName,
            height: lastDistance,
            massEM: mass,
            massKG: mass * EARTH_MASS_KG,
            OrbitalSpeed,
            OrbitalTimeInSec,
            OrbitalTimeInYears: (OrbitalTimeInSec / YEAR_IN_SEC).toFixed(3),
            orbitPosDegree: rotation,   // in Grad
            orbitPosNorm: (rotation / 360).toFixed(3)  // Normalisiert
        });

        lastDistance += rng() * 100000
    }
    return moons;
}

/**
 * Hier werden per Seed alle Objekte Ausgewählt, deren Positionen Generiert & Validiert und dann Abgespeichert.
 */
while (galaxy.length < config.count) {
    const angle = rng() * Math.PI * 2;
    const typeKeys = Object.keys(config.types);
    const chosenType = typeKeys.find(key => rng() < config.types[key].chance);

    if (!chosenType) continue;

    const typeConfig = config.types[chosenType];
    let distance = getRandomDistance(typeConfig.minDistance || 0, typeConfig.maxDistance || 0);

    const stars = getObjectType("star");

    // === nearStar ===
    if (typeConfig.preferred?.startsWith("nearStar")) {

        if (stars.length === 0) {
            // Kein Stern = Kein nearStar.
            // macht sinn oder?
            // würde ich so mal behaupten.
            // denke ich zumindest.
            continue;
        }

        const parts = typeConfig.preferred.split("-");
        if (parts.length === 3 && stars.length > 0) {
            const nearMin = parseFloat(parts[1]);
            const nearMax = parseFloat(parts[2]);
            const target = stars[Math.floor(rng() * stars.length)];

            const angleTo = rng() * Math.PI * 2;
            const dist = nearMin + rng() * (nearMax - nearMin);

            const x = target.x + Math.cos(angleTo) * dist;
            const y = target.y + Math.sin(angleTo) * dist;

            const { tooClose } = validateDistance(0, 0, chosenType);
            if (!tooClose) {
                galaxyPush(chosenType, x, y, generateUniqueName(chosenType, rng));
            }
            continue;
        }
    }

    // === Alle anderen ===
    const { tooClose, x, y } = validateDistance(distance, angle, chosenType);
    if (!tooClose) {
        galaxyPush(chosenType, x, y, generateUniqueName(chosenType, rng));
    }
}

fs.writeFileSync("./public/galaxy.json", JSON.stringify(galaxy));

console.log("Galaxie generiert mit", galaxy.length, "Objekten.");
console.log("Seed:", cc.string(config.seed));