const fs = require("fs");
const seedrandom = require("seedrandom");

/**
 * Die Config wo alle Informationen aufgeschrieben sind.\
 * Ohne sie würde alles den Bach Runter gehen XD.
 * 
 * Ich sollte mal schlafen gehen, wir haben es am 19.06.2025 um 02:02 Uhr Morgens XD.
 * 
 * @type {{"seed": "Main" | string, "radius": number, "count": number, "exponent": number, "mainBlackHoleName": string, "types": {"chance": number, "minDistance": number, "maxDistance": number, "preferred": string|"", "type": string[]}[]}} */
const config = JSON.parse(fs.readFileSync("config.json", "utf-8"));

/**
 * Der seed basierend auf der config.json/seed
 */
const rng = seedrandom(config.seed);

/**
 * Alle Objekte in der Galaxie die bisher Generiert wurden
 * 
 * @type {{type: string, x: number, y: number, name: string, metadata: []}} */
const galaxy = [];

/**
 * ähm... ja, danke ChatGPT. XD
 * 
 * @param r 
 * @param angle 
 * @returns 
 */
function polarToCartesian(r, angle) {
    return {
        x: r * Math.cos(angle),
        y: r * Math.sin(angle)
    };
}

/**
 * Hier wird eine Seedbasierte Distanz generiert.\
 * hab einfach ChatGPT Gefragt lol.
 * 
 * @param min {number}
 * @param max {number}
 * @returns {number}
 */
function getRandomDistance(min, max) {
    if (max === 0) max = config.radius;

    const exponent = config.exponent || 1; // 1 = linear, >1 = mehr im Zentrum

    //// return min + (max - min) * rng();

    return min + (max - min) * Math.pow(rng(), exponent);
}

/**
 * Die Funktion gibt es Extra dafür um Anomalienamen zu Generieren,
 * ich wollte nicht einfach nur Silben für die Namen verwenden also habe ich mich dafür hier entschieden.
 * 
 * @param rng 
 * @returns 
 */
function generateAnomalyName(rng) {
    /**
     * Die Prefixe, quasi die ersten Zeichen die Verwendet werden.
     * @type {string[]}
     */
    const prefix = ["RX", "ZB", "QK", "VR", "IA", "OR", "PA", "TR"];
    /**
     * Das sind die Suffixe die nach den Prefixen kommen,
     * sie bestehen aus nur eine Zahl oder MK + Zahl.
     * @type {string[]}
     */
    const suffix = [];
    for (let i = 0; i < 99; i++) {
        if (i < 10) suffix.push("-0" + i);
        else suffix.push("-" + i)
    }
    for (let i = 0; i < 99; i++) {
        if (i < 10) suffix.push("-0" + i);
        else suffix.push("-MK" + i)
    }

    return prefix[Math.floor(rng() * prefix.length)] + suffix[Math.floor(rng() * suffix.length)];
}

/**
 * Gibt den Sonnenmassenwert basierend auf x zurück.
 * 
 * @param x {number} wert zwischen 0.0000000000000001 - 1.0000000000000000
 * @returns {number} wert zwischen 0.0086 - 100
 */
function generateSolarMass(x) {
    // Der Minimalwert Basierend auf dem Minimalen wert über 0 vom Seed
    if (x <= 0) x = 0.0000000000000001;
    // Naja einfach den Wert auf 1 Setzen wenn es über 1 Geht, eigentlich unwahrscheinlich wenn man nur den seed selbst verwendet
    if (x > 1) x = 1.0000000000000000;

    return -(1 - Math.pow(x / 1.2, -0.4));
}

/**
 * Alle Validen Werte für jeden Spektrum.
 *
 * Hier habe ich natürlich einige Simplifikationen durchgeführt, besonders bei der Klasse M, L, T und Y.
 * 
 * @type {{class:string, tempmin:number, tempmax: number, massmin: number, massmax: number}[]}
 */
const VALID_SPECTRAL_CLASS_VALUES = [
    {class: "O", tempmin: 30000, tempmax: 60000, massmin: 16, massmax: Infinity},
    {class: "B", tempmin: 10000, tempmax: 30000, massmin: 2.1, massmax: 16},
    {class: "A", tempmin: 7500, tempmax: 10000, massmin: 1.7, massmax: 2.1},
    {class: "F", tempmin: 6000, tempmax: 7500, massmin: 1.1, massmax: 1.7},
    {class: "G", tempmin: 5300, tempmax: 6000, massmin: 0.8, massmax: 1.1},
    {class: "K", tempmin: 3500, tempmax: 5300, massmin: 0.5, massmax: 0.8},
    {class: "M", tempmin: 2500, tempmax: 3500, massmin: 0.03, massmax: 0.5},
    {class: "L", tempmin: 1300, tempmax: 2500, massmin: 0.05, massmax: 0.03},
    {class: "T", tempmin: 800, tempmax: 1300, massmin: 0.01, massmax: 0.03},
    {class: "Y", tempmin: 0, tempmax: 800, massmin: 0.0083, massmax: 0.01},
]

/**
 * Die Luminosität der Sonne in Watt
 * @type {number}
 */
const LUM_SOL = 3.828 * Math.pow(10, 26); // W
/**
 * Der Radius der Sonne in KM
 * @type {number}
 */
const R_SOL = 695700; // KM
/**
 * Die (Oberflächen-)Temperatur der Sonne in °K
 * @type {number}
 */
const T_SOL = 5778; // °K
/**
 * Die Masser der Sonne in KG
 * @type {number}
 */
const M_SOL = 1.989 * Math.pow(10, 30); // KG

/**
 * Hier wird die Spektralklasse des Sterns einfach basierend auf der Masse ausgegeben.\
 * Sehr Simpel Gehalten, ich meine wir brauchen hier keine Wissenschaftliche Simulation.
 * 
 * @param mass Die Masse des STerns
 * @returns {{class:string, subclass:string, temp:number, mass_sol: number, lum_sol: number, r_sol: number}}
 */
function getSolarSpectralClassData(mass) {
    /**@type {{class:string, subclass:string, temp:number, mass_sol: number, lum_sol: number, r_sol: number}} */
    let returnData = {};
    
    returnData.mass_sol = mass;

    /**@type {{class:string, tempmin:number, tempmax: number, massmin: number, massmax: number}} */
    let currentClass = null

    for (let i = 0; i < VALID_SPECTRAL_CLASS_VALUES.length; i++) {
        const specs = VALID_SPECTRAL_CLASS_VALUES[i]
        if (mass >= specs.massmin && mass <= specs.massmax) {currentClass = specs; returnData.class = specs.class; break;}
    }

    for (let i = 0; i < 10; i++) {
        const min = 0;
        const max = currentClass.tempmax - currentClass.tempmin;
        const relmass = mass - currentClass.massmin;
        
        const massPartStepSize = max / 10;

        if (relmass >= (min+massPartStepSize*i) && relmass <= (min+massPartStepSize*(i+1))) returnData.subclass = i;
    }

    returnData.temp = Math.round((rng() * (currentClass.tempmax-currentClass.tempmin)) + currentClass.tempmin);

    returnData.r_sol = Math.pow(returnData.mass_sol, 0.8);

    returnData.lum_sol = Math.pow((returnData.r_sol * R_SOL) / R_SOL, 2) * Math.pow(returnData.temp / T_SOL, 4);
    
    return returnData;
}

/**
 * Gibt Einen Namen basierend auf den Typ des Planeten zurück.
 * 
 * Sehr Interessant ist das er Basierend auf Silben Generiert wird, ich wusste davor nicht einmal, dass das geht.\
 * Danke ChatGPT XD.
 * 
 * @param type typ des Objektes
 * @param rng seed Funktion
 * @returns 
 */
function generateName(type, rng) {
    if (type === "anomaly") { return generateAnomalyName(rng) };

    /**@type {string[]} Silben von ChatGPT für die Namensgenerierung */
    const syllables = [
        // Silben V1
        "ka", "lo", "ra", "ze", "tu", "mi", "xa", "vi", "no",
        "shi", "dra", "qu", "ly", "tor", "zan", "ny", "fel", "vra",
        "zur", "kre", "tho", "bal", "ix", "sy", "jen", "kul", "orn",
        "nef", "ria", "sol", "mek", "tas", "lur", "xen", "cai", "vor",
        "hel", "ume", "zan", "tha", "py", "rek", "gri", "yul", "zan",
        "eph", "ari", "zho", "the", "mur", "dax", "nix", "zor", "lim",

        // Silben V2
        "bri", "clo", "dre", "fen", "gla", "hro", "jor", "kli", "mar",
        "nel", "oph", "pra", "qua", "rin", "sha", "tre", "uln", "vex",
        "wra", "xis", "yra", "zor", "bex", "dru", "fla", "gra", "hul",
        "jum", "kor", "lek", "mip", "nox", "opl", "pru", "qui", "rax",
        "syl", "tri", "uvo", "vyn", "wex", "xil", "yan", "zep", "zor",
        "bax", "cro", "dav", "elx", "fra", "gyn", "hax", "jin", "kre",
        "lom", "myr", "nov", "oph", "plu", "qir", "rum", "syn", "tor",
        "urn", "vok", "wir", "xon", "yar", "zun"
    ];

    let name = "";
    const length = 2 + Math.floor(rng() * 2);
    for (let i = 0; i < length; i++) {
        name += syllables[Math.floor(rng() * syllables.length)];
    }
    return name.charAt(0).toUpperCase() + name.slice(1);
}

const usedNames = new Set();

function generateUniqueName(type, rng) {
    let name;
    let tries = 0;
    do {
        name = generateName(type, rng);
        tries++;
        if (tries > 100) {
            name += `-ZU${Math.floor(rng() * 100)}`;
        }
    } while (usedNames.has(name));
    usedNames.add(name);
    return name;
}

/**
 * Validiert die Distanz zwischen Objekten, sodass Objekte nicht zu nahm und auch nicht zu weit voneinander sind
 * 
 * @param distance 
 * @param angle 
 * @param chosenType 
 * @returns 
 */
function validateDistance(distance, angle, chosenType) {
    const { x, y } = polarToCartesian(distance, angle)

    const stars = getObjectType("star");

    const typeConfig = config.types[chosenType]

    let dx = 0;
    let dy = 0;
    let tooClose = false

    if (galaxy.length === 0) {
        return { tooClose, x, y, dx, dy }
    }

    if (typeConfig.preferred.startsWith("nearStar")) {
        const parts = typeConfig.preferred.split("-");
        if (parts.length === 3) {
            const nearMin = parseFloat(parts[1]);
            const nearMax = parseFloat(parts[2]);

            const target = stars[Math.floor(rng() * stars.length)];
            const dist = nearMin + rng() * (nearMax - nearMin);
            dx = target.x + Math.cos(angle) * dist;
            dy = target.y + Math.sin(angle) * dist;
        }
    }

    if (typeConfig.preferred?.startsWith("deepSpace")) {
        const parts = typeConfig.preferred.split("-");
        if (parts.length === 2) {
            const min = parseFloat(parts[1]);
            for (const obj of galaxy) {
                if (obj.type === "star") {
                    const dx = obj.x - x;
                    const dy = obj.y - y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < min) {
                        tooClose = true;
                        break;
                    }
                }
            }
        }
    }

    for (const obj of galaxy) {
        if (obj.type === chosenType) {
            const dx = obj.x - x;
            const dy = obj.y - y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < typeConfig.minDistance) {
                tooClose = true;
                break;
            }
        }
    }

    return { tooClose, x, y, dx, dy }
}

function getObjectType(objectType) {
    const all = []
    for (const obj of galaxy) {
        if (obj.type == objectType) {
            all.push(obj)
        }
    }
    return all;
}

function getRandomObjectType(objectType) {
    const all = getObjectType(objectType)

    return all[(rng() * (all.length - 1))];
}

/**
 * Alle Validen Objekte die zur Generierung Verwendet werden dürfen.
 * @type {string[]}
 */
const VALID_SPACE_OBJECTS = ["mainBlackHole", "star", "planet", "astroidfieldt1_astroid", "astroidfieldt2_astroid", "astroidfieldt3_astroid", "rogue_planet", "anomaly", "blackHole"]
/**
 * Alle Validen Standard Ressourcen die AUF PLANETEN gefunden werden können.
 * @type {string[]}
 */
const VALID_PLANETARY_RESOURCES = ["iron_ore", "copper_ore", "cobalt_ore", "titanium_ore", "hydrogen", "argon", "uranium_ore", "tungsten_ore"];
/**
 * Alle Validen Fortschrittliche Ressourcen die AUF PLANETEN gefunden werden können.
 * @type {string[]}
 */
const VALID_PLANETARY_SPECIALRESOURCES = ["razetulim_ore", "zanzorlim_ore", "mekballim_ice", "helumelim_sulfide"];
/**
 * Alle Validen Ressourcen die AUF T-1, T-2 UND T3 ASTEROIDENFELDERN gefunden werden können.
 * @type {string[]}
 */
const VALID_AST_1_RESOURCES = ["methan_ice", "water_ice"];
/**
 * Alle Validen Ressourcen die AUF T-2 UND T3 ASTEROIDENFELDERN gefunden werden können.
 * @type {string[]}
 */
const VALID_AST_2_RESOURCES = ["naqium_ore"];
/**
 * Alle Validen Ressourcen die AUF T3 ASTEROIDENFELDERN gefunden werden können.
 * @type {string[]}
 */
const VALID_AST_3_RESOURCES = ["Nexus_carbonsulfide_ice"];

/**
 * Zulässige Ressourcen (nur Planeten/Einzelgänger/Asteroiden) (resource):\
 * iron, copper, cobalt, titanium, hydrogen, argon, uranium, tungston
 * 
 * Zulässige Spezialressourcen (nur Planeten/Einzelgänger/Asteroiden) (specialresource):\
 * razetulim, zanzorlim, mekballim, helumelim
 * 
 * Zulässige Sterneneigenschaften:\
 * erstmal Nix
 * 
 * Diese Informationen werden Automatisch Via Seed "Erfunden"
 * star:\
 * Spektralklasse via Seed + Tabelle\
 * Masse via Spektralklasse + Tabelle\
 * Subspektralklasse via Seed + Masse\
 * Temperatur via Seed + Subspektralklasse
 * 
 * @param type {string|"mainBlackHole"|"star"|"planet"|"astroidfieldt1_astroid"|"astroidfieldt2_astroid"|"astroidfieldt3_astroid"|"rogue_planet"|"anomaly"|"blackHole"}
 * @param x {number}
 * @param y {number}
 * @param name {string}
 * @param metadata {{resource: {}, specialresource: {}}}
 */
function galaxyPush(type, x, y, name, metadata = { resource: {}, specialresource: {} }) {

    /**@type {{resource: {res:string, amount:number}[], specialresource: {res:string, amount:number}[], informationType: "star"|"planet"|"astroidField", informationBase: {}|null}} */
    const metadata_edit1 = { resource: [], specialresource: [], features: [], informationType: null, informationsBase: null };
    const metadata_edit2 = {};

    if (type != "mainBlackHole") {
        /**
         * Die Grund-Informationen für den Stern
         * 
         * starTemperature: Sternentemparatur in °K\
         * starMass: Sternenmasse in Sonnenmassen\
         * starLum: Sternenleuchtstärke in Sonnenleuchtstärken
         * starSpectral: Spektrum des Sterns:
         *  - h=Hauptsprektrum
         *  - s=Subspektrum
         * 
         * Hauptspektrum: Y, T, L, M, K, G (zb. wie unsere Sonne), F, A, B, O\
         * Subspektrul: Y0-Y9, T0-T9, L0-L9, M0-M9, K0-K9, G0-G9 (unsere Sonne ist G-2), F0-F9, A0-A9, B0-B9, O0-O9
         * 
         * @type {{starTemperature: number, starMass: number, starRad: number, starLum: number, starSpectral: {h:"Y"|"T"|"L"|"M"|"K"|"G"|"F"|"A"|"B"|"O"|string, s:"0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"|string}}}
         */
        const informationStar = {
            starTemperature: null,
            starMass: null,
            starLum: null,
            starRad: null,
            starSpectral: { h: null, s: null }
        }

        /**
         * 
         * 
         * @type {{}}
         */
        const planet = {}
        /**
         * 
         * 
         * @type {{}}
         */
        const astroidField = {}

        if (type == "star") { metadata_edit1.informationType = "star"; metadata_edit1.informationBase = informationStar }

        //* Ressourcen (resource)
        //// if (metadata.resource.iron != null) { metadata_edit1.resource.push({ res: "iron", amount: metadata.resource.iron }) }
        //// if (metadata.resource.copper != null) { metadata_edit1.resource.push({ res: "copper", amount: metadata.resource.copper }) }
        //// if (metadata.resource.cobalt != null) { metadata_edit1.resource.push({ res: "cobalt", amount: metadata.resource.cobalt }) }
        //// if (metadata.resource.titanium != null) { metadata_edit1.resource.push({ res: "titanium", amount: metadata.resource.titanium }) }
        //// if (metadata.resource.hydrogen != null) { metadata_edit1.resource.push({ res: "hydrogen", amount: metadata.resource.hydrogen }) }
        //// if (metadata.resource.argon != null) { metadata_edit1.resource.push({ res: "argon", amount: metadata.resource.argon }) }
        //// if (metadata.resource.uranium != null) { metadata_edit1.resource.push({ res: "uranium", amount: metadata.resource.uranium }) }
        //// if (metadata.resource.tungsten != null) { metadata_edit1.resource.push({ res: "tungsten", amount: metadata.resource.tungsten }) }
        for (const [res, amount] of Object.entries(metadata.resource || {})) {
            if (VALID_PLANETARY_RESOURCES.includes(res)) {
                metadata_edit1.resource.push({ res, amount });
            }
        }

        //* Spezielle Ressourcen (specialresource)
        //// if (metadata.specialresource.razetulim != null) { metadata_edit1.specialresource.push({ res: "razetulim", amount: metadata.specialresource.razetulim }) }
        //// if (metadata.specialresource.zanzorlim != null) { metadata_edit1.specialresource.push({ res: "zanzorlim", amount: metadata.specialresource.zanzorlim }) }
        //// if (metadata.specialresource.mekballim != null) { metadata_edit1.specialresource.push({ res: "mekballim", amount: metadata.specialresource.mekballim }) }
        //// if (metadata.specialresource.helumelim != null) { metadata_edit1.specialresource.push({ res: "helumelim", amount: metadata.specialresource.helumelim }) }
        for (const [res, amount] of Object.entries(metadata.specialresource || {})) {
            if (VALID_PLANETARY_SPECIALRESOURCES.includes(res)) {
                metadata_edit1.specialresource.push({ res, amount });
            }
        }

        //// Planetare/Stellare/Interstellare Eigenschaften (features)
        //// for (let i = 0; i < metadata.features.length; i++) {
        ////     const e = metadata.features[i];
        ////     for (let j = 0; j < VALID_PLANETARY_FEATURES.length; j++) {
        ////         const f = VALID_PLANETARY_FEATURES[j];
        ////         if (e.toLowerCase() == f.toLowerCase()) metadata_edit1.features.push(f)
        ////     }
        //// }

        if (type == "star") {
            const sunMass = generateSolarMass(rng());

            let info = informationStar;

            let specs = getSolarSpectralClassData(sunMass);

            info.starLum = specs.lum_sol;
            info.starMass = specs.mass_sol;
            info.starRad = specs.r_sol
            info.starSpectral = {h: specs.class, s: specs.subclass};
            info.starTemperature = specs.temp;

            metadata_edit1.informationType = "star";
            metadata_edit1.informationBase = info;
        }

    } else {
        x = 0;
        y = 0;
        name = config.mainBlackHoleName;
    }

    if (metadata_edit1.resource.length != 0) { metadata_edit2.resource = metadata_edit1.resource }
    if (metadata_edit1.specialresource.length != 0) { metadata_edit2.specialresource = metadata_edit1.specialresource }
    if (metadata_edit1.informationType != null && metadata_edit1.informationBase != null) {metadata.informationType = metadata_edit1.informationType; metadata_edit2.informationBase = metadata_edit1.informationBase}

    //// const distanceToCenter = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    const distanceToCenter = Math.hypot(x, y);

    const d = {
        type,
        x,
        y,
        name,
        distanceToCenter,
        metadata: metadata_edit2
    }
    console.log(JSON.stringify(d));

    // console.log(d.chosenType);

    galaxy.push(d)
}
galaxyPush("mainBlackHole")

/**
 * Hier werden per Seed alle Objekte Ausgewählt, deren Positionen Generiert & Validiert und dann Abgespeichert.
 */
while (galaxy.length < config.count) {
    const angle = rng() * Math.PI * 2;
    const typeKeys = Object.keys(config.types);
    const chosenType = typeKeys.find(key => rng() < config.types[key].chance);

    if (!chosenType) continue;

    const typeConfig = config.types[chosenType];
    let distance = getRandomDistance(typeConfig.minDistance || 0, typeConfig.maxDistance || 0);

    const stars = getObjectType("star");

    // === nearStar ===
    if (typeConfig.preferred?.startsWith("nearStar")) {
        
        if (stars.length === 0) {
            // Kein Stern = Kein nearStar.
            // macht sinn oder?
            continue;
        }

        const parts = typeConfig.preferred.split("-");
        if (parts.length === 3 && stars.length > 0) {
            const nearMin = parseFloat(parts[1]);
            const nearMax = parseFloat(parts[2]);
            const target = stars[Math.floor(rng() * stars.length)];

            const angleTo = rng() * Math.PI * 2;
            const dist = nearMin + rng() * (nearMax - nearMin);

            const x = target.x + Math.cos(angleTo) * dist;
            const y = target.y + Math.sin(angleTo) * dist;

            const { tooClose } = validateDistance(0, 0, chosenType);
            if (!tooClose) {
                galaxyPush(chosenType, x, y, generateUniqueName(chosenType, rng));
            }
            continue;
        }
    }

    // === Alle anderen ===
    const { tooClose, x, y } = validateDistance(distance, angle, chosenType);
    if (!tooClose) {
        galaxyPush(chosenType, x, y, generateUniqueName(chosenType, rng));
    }
}

fs.writeFileSync("./public/galaxy.json", JSON.stringify(galaxy));
console.log(rng());

console.log("💫 Galaxie generiert mit", galaxy.length, "Objekten.");